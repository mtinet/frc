# 아키텍처 및 데이터 전달 방식

## 전체 구조

```
┌─────────────────────────────────────────┐
│         Flask 서버 (app.py)             │
│  ┌───────────────────────────────────┐  │
│  │  메모리 기반 상태 저장 (state)     │  │
│  │  - score: 점수 정보                │  │
│  │  - current_media: 미디어 정보      │  │
│  │  - layout: 레이아웃 설정           │  │
│  └───────────────────────────────────┘  │
│                                          │
│  API 엔드포인트:                         │
│  - GET  /api/state  → 상태 조회         │
│  - POST /api/state  → 상태 업데이트      │
│  - POST /api/youtube → 유튜브 설정      │
│  - POST /api/clear-media → 미디어 클리어│
└─────────────────────────────────────────┘
           ▲                    ▲
           │                    │
           │                    │
    ┌──────┴──────┐    ┌────────┴────────┐
    │             │    │                 │
    │ 컨트롤 박스 │    │    뷰박스        │
    │ (control)   │    │    (view)       │
    │             │    │                 │
    │ - 점수 입력 │    │ - 점수 표시     │
    │ - 미디어 제어│    │ - 미디어 표시   │
    │ - 설정 변경 │    │ - 전체화면 모드  │
    └─────────────┘    └─────────────────┘
```

## 데이터 전달 방식

### 1. **서버 중심 아키텍처 (Server-Centric)**

두 웹페이지(컨트롤 박스와 뷰박스)는 **독립적인 클라이언트**이며, 모두 **같은 Flask 서버**와 통신합니다.

- **컨트롤 박스** (`/`): 사용자 입력을 받아 서버에 상태 업데이트 요청
- **뷰박스** (`/view`): 주기적으로 서버에서 상태를 조회하여 화면 업데이트

### 2. **상태 저장 방식**

현재는 **메모리 기반** 상태 저장을 사용합니다:

```python
# app.py의 전역 변수
state = {
    'score': {
        'team1': 0,
        'team2': 0,
        'team1_name': 'Team 1',
        'team2_name': 'Team 2'
    },
    'current_media': {
        'type': None,
        'url': None,
        'youtube_id': None
    },
    'layout': 'default'
}
```

**장점:**
- 빠른 응답 속도
- 구현이 간단함
- 별도 데이터베이스 불필요

**단점:**
- 서버 재시작 시 상태 초기화
- 여러 서버 인스턴스 간 상태 공유 불가

### 3. **통신 흐름**

#### 컨트롤 박스 → 서버 (상태 업데이트)

```
사용자 액션 (점수 변경, 미디어 설정)
    ↓
JavaScript: fetch('/api/state', { method: 'POST', body: JSON })
    ↓
Flask: POST /api/state 엔드포인트
    ↓
서버 메모리의 state 객체 업데이트
    ↓
업데이트된 state 반환
    ↓
컨트롤 박스 UI 업데이트
```

#### 뷰박스 → 서버 (상태 조회)

```
페이지 로드 또는 주기적 폴링 (1초마다)
    ↓
JavaScript: fetch('/api/state')
    ↓
Flask: GET /api/state 엔드포인트
    ↓
서버 메모리의 state 객체 반환
    ↓
뷰박스 화면 업데이트 (점수, 미디어)
```

### 4. **실시간 동기화 메커니즘**

**폴링(Polling) 방식**을 사용합니다:

- **컨트롤 박스**: 2초마다 상태 동기화
- **뷰박스**: 1초마다 상태 동기화

```javascript
// control.html
setInterval(syncState, 2000); // 2초마다

// view.html
setInterval(syncState, 1000); // 1초마다
```

**왜 폴링인가?**
- 구현이 간단함
- 별도 WebSocket 서버 불필요
- 네트워크 오류 시 자동 재시도 가능

**향후 개선 가능:**
- WebSocket을 사용한 실시간 양방향 통신
- Server-Sent Events (SSE) 사용

### 5. **API 엔드포인트 상세**

#### GET /api/state
- **용도**: 현재 상태 조회
- **응답**: 전체 state 객체
```json
{
  "score": {
    "team1": 10,
    "team2": 5,
    "team1_name": "Team 1",
    "team2_name": "Team 2"
  },
  "current_media": {
    "type": "youtube",
    "url": "https://youtube.com/...",
    "youtube_id": "abc123"
  },
  "layout": "default"
}
```

#### POST /api/state
- **용도**: 상태 업데이트
- **요청 본문**: 업데이트할 부분만 포함
```json
{
  "score": {
    "team1": 15
  }
}
```
- **응답**: 업데이트된 전체 state 객체

#### POST /api/youtube
- **용도**: 유튜브 영상 설정
- **요청 본문**: 
```json
{
  "url": "https://www.youtube.com/watch?v=abc123"
}
```
- **응답**: 
```json
{
  "status": "success",
  "youtube_id": "abc123"
}
```

### 6. **별도 모니터 사용 시나리오**

1. **같은 컴퓨터, 다른 브라우저 탭/창**
   - 노트북: `http://localhost:8080` (컨트롤 박스)
   - 별도 모니터: `http://localhost:8080/view` (뷰박스)
   - 두 페이지 모두 같은 서버와 통신

2. **같은 네트워크, 다른 기기**
   - 노트북: `http://192.168.1.100:8080` (컨트롤 박스)
   - 별도 모니터 연결 기기: `http://192.168.1.100:8080/view` (뷰박스)
   - 서버는 `host='0.0.0.0'`으로 설정되어 있어 네트워크 접근 가능

### 7. **에러 처리**

- **네트워크 오류**: fetch 실패 시 콘솔에 에러 로그, 사용자에게 시각적 피드백
- **서버 오류**: HTTP 상태 코드 확인 후 에러 메시지 표시
- **연결 실패**: 뷰박스에 "서버 연결 실패" 메시지 표시

## 향후 개선 방향

1. **WebSocket 통신**: 실시간 양방향 통신으로 지연 시간 감소
2. **데이터베이스 저장**: SQLite 또는 JSON 파일로 상태 영구 저장
3. **멀티 서버 지원**: Redis 등을 사용한 분산 상태 관리
4. **인증/보안**: 네트워크 접근 시 인증 추가
